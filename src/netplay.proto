syntax = "proto2";

package netplay;
//XXX option optimize_for = LITE_RUNTIME;


// Wrapper packet
// Only one field must be set.
message Packet {
  optional PktInput input = 1;
  optional PktNewGarbage new_garbage = 2;
  optional PktUpdateGarbage update_garbage = 3;
  optional PktGarbageState garbage_state = 4;
  optional PktChat chat = 10;
  optional PktNotification notification = 11;
  optional PktServerConf server_conf = 20;
  optional PktServerState server_state = 21;
  optional PktPlayerJoin player_join = 30;
  optional PktPlayerConf player_conf = 31;
  optional PktPlayerState player_state = 32;
  optional PktPlayerRank player_rank = 33;
  optional PktPlayerField player_field = 34;
}


// Chat message from a player
message PktChat {
  required uint32 plid = 1;
  required string txt = 2;
}

// Server message
message PktNotification {
  enum Severity {
    MESSAGE = 1;
    NOTICE  = 2;
    WARNING = 3;
    ERROR   = 4;
  }
  required string txt = 1;
  optional Severity severity = 2 [default = MESSAGE];
}


// Field configuration
// If name is empty (the default) it is a custom configuration.
// Otherwise, name must be a valid configuration name and other fields
// may be ignored.
message FieldConf {
  // random color picking mode for raised lines
  enum RaiseAdjacent {
    NEVER     = 1;
    ALWAYS    = 2;
    ALTERNATE = 3;
  }
  optional string name = 1 [default = ""];
  repeated uint32 raise_speeds = 2 [packed = true];
  required uint32 manual_raise_speed = 3;
  repeated uint32 raise_speed_changes = 18 [packed=true];
  required uint32 swap_tk = 4;
  required uint32 stop_combo_0 = 5;
  required uint32 stop_combo_k = 6;
  required uint32 stop_chain_0 = 7;
  required uint32 stop_chain_k = 8;
  required uint32 lost_tk = 9;
  required uint32 gb_hang_tk = 10;
  required uint32 flash_tk = 11;
  required uint32 levitate_tk = 12;
  required uint32 pop_tk = 13;
  required uint32 pop0_tk = 14;
  required uint32 transform_tk = 15;
  required uint32 color_nb = 16;
  required RaiseAdjacent raise_adjacent = 17;
}


////  Server

// Set server configuration
// Only valid in LOBBY client state.
// If field_confs is empty, current field configurations are not updated.
message PktServerConf {
  optional uint32 pl_nb_max    = 1 [default =     2];
  optional uint32 tk_usec      = 2 [default = 16667]; // 60Hz
  optional uint32 tk_lag_max   = 3 [default =    60]; // 1s (at 60Hz)
  optional uint32 tk_start_countdown = 4 [default = 180]; // 3s (at 60Hz)
  repeated FieldConf field_confs = 10;
}

// Change server state
message PktServerState {
  enum State {
    LOBBY = 1;  // no active match
    GAME_INIT = 2;  // match init are being sent
    GAME_READY = 3;  // init done, waiting for players to be ready
    GAME = 4;  // match is running
  }
  required State state = 1;
}


////  Player and field

// Client join request.
// The server will reply with a PktPlayerConf with join field set to true.
message PktPlayerJoin {
  optional string nick = 2;
}

// Set player configuration
// For new players, nick and field_conf must be set.
// From client, only valid in LOBBY server state.
message PktPlayerConf {
  required uint32 plid = 1;
  optional string nick = 2;
  optional FieldConf field_conf = 5;
  optional bool join = 10 [default = false];
}

// Change player state
message PktPlayerState {
  enum State {
    QUIT = 1;  // left or is leaving the server
    LOBBY = 2;  // in the lobby
    LOBBY_READY = 3;  // in the lobby, ready to play
    GAME_READY = 5;  // init done, waiting for other players to be ready
    // states set on server state change, not needed in protocol
    GAME_INIT = 4;  // initializing game
    GAME = 6;  // in game
  }
  required uint32 plid = 1;
  required State state = 2;
}

// Rank a player's field
message PktPlayerRank {
  required uint32 plid = 1;
  required uint32 rank = 2; // 0: still playing, 1: first, 2: second ...
}

// Field description
// Sent before match starts to initialize fields.
message PktPlayerField {
  message BkColor {
    enum State {
      REST        = 1;
      FALL        = 2;
      LAID        = 3;
      LEVITATE    = 4;
      FLASH       = 5;
      MUTATE      = 6;
      CLEARED     = 7;
      TRANSFORMED = 8;
    }
    required State state = 1;
    required uint32 color = 2;
  }

  message BkGarbage {
    enum State {
      REST        = 1;
      FALL        = 2;
      FLASH       = 3;
      MUTATE      = 4;
      TRANSFORMED = 5;
    }
    required State state = 1;
    //TODO required uint32 garbage
  }

  // Block content
  // Either bk_color or bk_garbage must be set, but not both.
  message Block {
    optional BkColor bk_color = 1;
    optional BkGarbage bk_garbage = 2;
    optional bool swapped = 3 [default = false];
    optional bool chaining = 4 [default = false];
    optional uint32 ntick = 5 [default = 0];
  }

  required uint32 plid = 1;
  required fixed32 seed = 2;
  // Grid content, starting at (x,y) = (0,0)
  // repeat order: (0,0) (1,0) ... (0,1) (1,1) ...
  repeated Block blocks = 10;
}


// Input for a field
// Keys of skipped frames default to 0 (no input).
// If keys is empty, input for given tick is not provided but skipped frames
// are processed.
message PktInput {
  // keys field value is a OR-ed set of enum values
  enum Keys {
    NONE  =  0;
    UP    =  1;
    DOWN  =  2;
    LEFT  =  4;
    RIGHT =  8;
    SWAP  = 16;
    RAISE = 32;
  };
  required uint32 plid = 1;
  required uint32 tick = 2; // tick of the first given keys
  repeated uint32 keys = 3 [packed = true]; // successive input keys
}


////  Garbages

enum GarbageType {
  COMBO   = 1;
  CHAIN   = 2;
  SPECIAL = 3;
}

// New garbage
message PktNewGarbage {
  required uint32 gbid = 1;
  optional uint32 plid_from = 2;
  required uint32 plid_to = 3;
  required uint32 pos = 4;
  required GarbageType type = 5;
  required uint32 size = 6;
}

// Update a garbage
// Only valid when garbage is hanging
message PktUpdateGarbage {
  required uint32 gbid = 1;
  optional uint32 plid_to = 3;
  optional uint32 pos = 4; // required if plid_to is set
  optional uint32 size = 6;
}

// Change garbage state
message PktGarbageState {
  enum State {
    WAIT = 1; // waiting for being dropped (requested by server)
    DROP = 2; // drop confirmed by client
  }
  required uint32 gbid = 1;
  required State state = 2;
}

